# Coding Superagent

## Executive Summary

Membria introduces the **Superagent Architecture**, which transforms stateless AI agents (like Claude Code) into **decision-aware development companions** that remember project history, learn from outcomes, and prevent teams from repeating mistakes.

**Core value proposition:**
- **For developers:** AI that remembers what worked and what didn't.
- **For teams:** Shared memory that survives personnel changes and context switches.
- **For budgets:** Architecture that minimizes LLM token consumption by avoiding redundant context in Multi-Agent systems.

---

## The Problem: Stateless AI in Vibe Coding

### What is Vibe Coding
Vibe coding = describing what you want in natural language, letting AI write the code. It works great for one-off scripts and prototypes, but breaks down in long-term projects.

### Where It Breaks Down

| Situation | What Happens |
|-----------|--------------|
| Project lives > 1 week | AI doesn't remember yesterday's decisions |
| Multiple developers | No shared context between team members |
| Return to code after a month | "Why is it written this way?" â€” nobody knows |
| Similar problem solved before | AI makes the same mistake again |
| Bad approach tried previously | No memory â†’ team tries it again |

### The Root Cause
Current AI coding assistants are **stateless**: every prompt is processed independently with no memory of past architectural decisions or "negative knowledge" (what failed).

---

## The Solution: Membria Superagent Architecture

### Instead of Multiple Agents (Multi-Agent)
Typical multi-agent systems (Orchestrator â†’ Planner â†’ Coder â†’ Reviewer) burn **70,000+ tokens** per task because each agent receives full redundant context.

### Membria Approach: One Agent + Smart Context
```
âœ… MEMBRIA SUPERAGENT:

User prompt
    â†“
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚  Membria Graph Query            â”‚  â† Local, 0 tokens
â”‚  "What's relevant for this?"    â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
    â†“
[Only relevant context: ~2K tokens]
    â†“
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚  Single Claude Code Call        â”‚  â† 6-10K tokens total
â”‚  With injected context          â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
    â†“
Code + Auto-captured decision record
```
**Result: 10x fewer tokens, persistent memory, predictable costs.**

---

## Architecture

```mermaid
flowchart TD
    subgraph "IDE / PR / CI Layer"
        A[VS Code, GitHub PR, Jira, CI jobs]
    end
    A --> B(Claude Control Plane - CCP)
    
    subgraph CCP [Claude Control Plane (CCP)]
        B --> C(Task Router)
        C --> D(Agent / TENN<br/>graph + logic)
        D --> E(Policy Engine<br/>what is allowed)
        E --> F(MCP Server - Runtime Control)
    end

    F -->|context injection, tool exposure| G(Claude Code<br/>stateless)
    F --> H(Debias Validators)
    H --> I(Membria Reasoning Graph)
    
    subgraph Feedback [Async Feedback Loop]
        I --> J{Outcome Capture Layer}
        J -->|Updates Beliefs/LoRA| I
    end
```

## Detailed Flow: Library Selection Decision

### Scenario
Developer in VS Code writes: "Add REST API for user management, need to choose a framework"

### Step 1: Task Router Classification
```
Input: "Add REST API for user management, need to choose a framework"

Classification Analysis:
â”œâ”€â”€ Keywords detected: "choose", "framework"
â”œâ”€â”€ Multiple alternatives implied: yes
â”œâ”€â”€ Architectural impact: yes (API framework affects whole service)
â””â”€â”€ Decision type: LIBRARY_CHOICE

Result: Route to DECISION flow (not tactical)
```

### Step 2: Pre-Generation Context Fetch
```
Query to Reasoning Graph:

MATCH (d:Decision)-[:ABOUT]->(t:Topic)
WHERE t.name IN ["REST API", "framework", "HTTP server"]
  AND d.repo = "current-repo"
RETURN d, d.outcome, d.assumptions

Results:
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚ Decision #47 (8 months ago)                                        â”‚
â”‚ Statement: "Use Express.js for API gateway"                        â”‚
â”‚ Outcome: SUCCESS                                                   â”‚
â”‚ Notes: "Worked well, team familiar"                                â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚ Decision #89 (6 months ago)                                        â”‚
â”‚ Statement: "Use custom middleware for authentication"              â”‚
â”‚ Outcome: FAILURE                                                   â”‚
â”‚ Notes: "Security vulnerability found, had to rewrite"              â”‚
â”‚ Negative Knowledge: "Avoid custom auth middleware"                 â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚ Team Calibration (library choices):                                â”‚
â”‚ â€¢ Average confidence: 0.78                                         â”‚
â”‚ â€¢ Actual success rate: 0.61                                        â”‚
â”‚ â€¢ Calibration gap: +17% (overconfident)                           â”‚
â”‚ â€¢ Recommendation: Reduce stated confidence by ~15%                 â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
```

### Step 3: Decision Surface Display (in IDE)
Developer sees inline panel before Claude generates anything:

```
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚  ğŸ§  Membria Decision Context                                        â”‚
â”‚                                                                     â”‚
â”‚  â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”  â”‚
â”‚                                                                     â”‚
â”‚  ğŸ“Š RELEVANT HISTORY                                                â”‚
â”‚                                                                     â”‚
â”‚  âœ… Express.js worked well (8 months ago)                          â”‚
â”‚     "API gateway - team was familiar, stable in prod"              â”‚
â”‚                                                                     â”‚
â”‚  âŒ Custom middleware failed (6 months ago)                        â”‚
â”‚     "Security vulnerability, 2-week rewrite"                       â”‚
â”‚     âš ï¸ NEGATIVE KNOWLEDGE: Avoid custom auth solutions             â”‚
â”‚                                                                     â”‚
â”‚  â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”  â”‚
â”‚                                                                     â”‚
â”‚  ğŸ“ˆ TEAM CALIBRATION                                                â”‚
â”‚                                                                     â”‚
â”‚  Your team tends to be 17% overconfident in library choices.       â”‚
â”‚  If you feel 80% confident, historical accuracy suggests ~65%.     â”‚
â”‚                                                                     â”‚
â”‚  â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”  â”‚
â”‚                                                                     â”‚
â”‚  ğŸ’¡ CONSIDERATIONS                                                  â”‚
â”‚                                                                     â”‚
â”‚  â€¢ Express.js: proven in this repo, team knows it                  â”‚
â”‚  â€¢ Fastify: faster, but team has no experience                     â”‚
â”‚  â€¢ Koa: minimal, might need more custom code                       â”‚
â”‚                                                                     â”‚
â”‚  â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”  â”‚
â”‚                                                                     â”‚
â”‚  Ready to proceed?                                                  â”‚
â”‚                                                                     â”‚
â”‚  [ Proceed with Claude ] [ Review History ] [ I'll decide myself ] â”‚
â”‚                                                                     â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
```

### Step 4: Developer Interaction
Developer clicks "Proceed with Claude" and adds: "Let's go with Fastify for better performance"

### Step 5: Decision Capture (DBB)
Before code generation, system captures:

```json
{
  "decision_id": "dec_142",
  "timestamp": "2025-02-06T14:32:00Z",
  "statement": "Use Fastify for REST API in user-service",
  "alternatives_considered": [
    {
      "option": "Express.js",
      "reason_rejected": "Want better performance"
    },
    {
      "option": "Koa",
      "reason_rejected": "Too minimal"
    },
    {
      "option": "Custom",
      "reason_rejected": "Negative knowledge from dec_89"
    }
  ],
  "confidence": {
    "stated": 0.75,
    "calibrated": 0.62,
    "calibration_note": "Adjusted for team's +17% overconfidence in library choices"
  },
  "assumptions": [
    "Fastify handles our expected load (10k req/s)",
    "Team can learn Fastify quickly",
    "Fastify ecosystem has needed plugins"
  ],
  "predicted_outcome": {
    "description": "Stable, performant API ready in 2 weeks",
    "success_criteria": [
      "API handles 10k req/s",
      "No critical bugs in first month",
      "Team onboarding < 1 week"
    ]
  },
  "context_hash": "sha256:abc123...",
  "status": "CAPTURED",
  "linked_artifacts": {
    "pr": null,
    "commit": null,
    "jira": "PROJ-456"
  },
  "negative_knowledge_acknowledged": [
    "dec_89: Avoid custom auth middleware"
  ]
}
```

### Step 6: MCP Server Context Injection
Claude Code receives enriched context.

---

## Token Economics: Superagent vs Multi-Agent

### Per-Task Comparison

| Aspect | Multi-Agent System | Membria Superagent |
|--------|-------------------|--------------------|
| **Architecture** | N agents Ã— full context | 1 agent Ã— smart context |
| **Tokens per task** | 70,000+ | 6,000-10,000 |
| **Token growth** | O(nÂ²) | O(1) |
| **Memory** | None (stateless) | Persistent (Graph) |
| **Cost Structure** | Usage-based, unpredictable | Subscription-based, fixed |

**Multi-agent vendors want you to use MORE agents. Membria wants you to use BETTER context to save tokens.**

---

## Bottom Line

Multi-agent architecture solves "how to divide work" by creating a new problem: context fragmentation. **Membria Superagent** solves the root problem: **giving one agent the right context.**

**Vibe coding stops being "generate from scratch every time" and becomes "generate with project memory.â€**
